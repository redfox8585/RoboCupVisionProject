<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="https://threejs.org/build/three.js"></script>
		<script> 
			const createSoccerField = function(){
				const fieldAspectRatio = 2400.0/1530; // pixel_width/pixel_height
				const fieldWidth = 10.0; // goal side lenght
				const geometry = new THREE.PlaneGeometry( fieldWidth,  fieldWidth/fieldAspectRatio );
				// image is under Creative Commons Zero 1.0 Public Domain License: https://openclipart.org/faq
				const texture = new THREE.TextureLoader().load( 'https://openclipart.org/image/2400px/svg_to_png/12769/Anonymous-football-pitch.png' );
				const material = new THREE.MeshPhongMaterial( { map: texture } );
				return new THREE.Mesh( geometry, material );
			}

			const createBall = function(){
				const ballRadius = 0.1;
				const geometry = new THREE.SphereGeometry( ballRadius, 32, 32 );
				const material = new THREE.MeshPhongMaterial( {color: 0xff0000} );
				const ball = new THREE.Mesh( geometry, material );
				ball.position.z = ballRadius;
				return ball;
			}

			const createObstacles = function(){
				
				const geometry = new THREE.BoxGeometry( 0.5, 0.3, 1 );
				const material = new THREE.MeshPhongMaterial( {color: 0x0000ff} );
				const cube = new THREE.Mesh( geometry, material );
				cube.position.z = 0.15

				objects = new THREE.Object3D();

				objects.add(cube.clone());
		
				cube.position.x = 1.6;
				cube.position.y = -0.6;
				objects.add(cube.clone());
				
				cube.position.x = -1;
				cube.position.y = -1;
				objects.add(cube.clone());

				return objects;
			}

			const createCamera = function(){
				const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.y = -2.5;
				camera.position.z = 3;
			    camera.up = new THREE.Vector3(0,0,1);
				camera.lookAt(0,0,0);
				return camera;			
			}

			const createLight = function(x,y,z){
				const light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( x,y,z );
				light.lookAt(0,0,0);
			
				light.shadow.mapSize.width = 2048;
				light.shadow.mapSize.height = 2048;

				return light;
			}

			const enableShadows = function(scene){
				scene.receiveShadow = true;
				scene.castShadow = true;
				
				for(c of scene.children)
					enableShadows(c);
			}

			const friction = function(velo, dt){
				let acceleration = -0.25;

				let v = velo.length() + acceleration * dt;
				if(v < 0)
					v = 0;

				return velo.setLength(v);
			}

			// the ball will receive a velocity impulse v at the time point t
			let v = [ { t : 0, v: new THREE.Vector2(1,0)}, { t: 5, v: new THREE.Vector2(0,1)}, { t: 10, v: new THREE.Vector2(-1,0)}, { t: 15, v: new THREE.Vector2(-0.7,-0.7)}, { t : 20, v: new THREE.Vector2(1,0)}, { t: 25, v: new THREE.Vector2(0,1)}, { t: 30, v: new THREE.Vector2(-1,0)}, { t: 35, v: new THREE.Vector2(-0.7,-0.7)}];

			const velocityImpulse = function(timeSinceStart, velo){
				let t = timeSinceStart;

				for(var i = 0; i < v.length; i++){
					if(v[i] != null && v[i].t < t){
						velo.add(v[i].v);
						v[i] = null;
					}
				}

				return velo;
			}

			let velo = new THREE.Vector2(0,0);
			let pos = new THREE.Vector2(-1,-1);
			let lastTime = 0;

			const ballAnimation = function(timeSinceStart){
				let dt = timeSinceStart - lastTime;
				lastTime = timeSinceStart;

				velo = friction(velo, dt);
				
				velo = velocityImpulse(timeSinceStart, velo);

				pos.add(velo.clone().multiplyScalar(dt));

				return pos;
			}

			const scene = new THREE.Scene();
			const camera = createCamera();

			const renderer = new THREE.WebGLRenderer();
			renderer.shadowMap.enabled = true;
			renderer.setClearColor(new THREE.Color( 0xffffff ), 1.0);
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			const soccerField = createSoccerField();
			scene.add( soccerField  );

			const ball = createBall();
			scene.add( ball );

			const obstacles = createObstacles();
			scene.add(obstacles);

			const dLight = createLight(3,3,10);
			scene.add(dLight);
			
			const aLight = new THREE.AmbientLight( 0x808080 );
			scene.add( aLight );

			enableShadows(scene);

			const render = function () {
				const oneSecondInMs = 1000;
				let t = performance.now() / oneSecondInMs;

				p = ballAnimation(t);

				ball.position.x = p.x;
				ball.position.y = p.y;

				console.log("x: " + p.x + ", " + p.y);

				camera.position.x = -p.x;
				camera.position.y = -p.y;
				camera.position.z = 3;
			    camera.lookAt(0,0,0);

				renderer.render( scene, camera );
				requestAnimationFrame( render );
			};

			render();
		</script>
	</body>
</html>