<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="https://threejs.org/build/three.js"></script>
		<script> 
			const createSoccerField = function(){
				const fieldAspectRatio = 2400.0/1530; // pixel_width/pixel_height
				const fieldWidth = 10.0; // goal side lenght
				const geometry = new THREE.PlaneGeometry( fieldWidth,  fieldWidth/fieldAspectRatio );
				// image is under Creative Commons Zero 1.0 Public Domain License: https://openclipart.org/faq
				const texture = new THREE.TextureLoader().load( 'https://openclipart.org/image/2400px/svg_to_png/12769/Anonymous-football-pitch.png' );
				const material = new THREE.MeshPhongMaterial( { map: texture } );
				return new THREE.Mesh( geometry, material );
			}

			const createBall = function(){
				const ballRadius = 0.1;
				const geometry = new THREE.SphereGeometry( ballRadius, 32, 32 );
				const material = new THREE.MeshPhongMaterial( {color: 0xff0000} );
				const ball = new THREE.Mesh( geometry, material );
				ball.position.z = ballRadius;
				return ball;
			}

			const createObstacles = function(){
				
				const geometry = new THREE.BoxGeometry( 0.5, 0.3, 1 );
				const material = new THREE.MeshPhongMaterial( {color: 0x0000ff} );
				const cube = new THREE.Mesh( geometry, material );
				cube.position.z = 0.15

				objects = new THREE.Object3D();

				objects.add(cube.clone());
		
				cube.position.x = 1.6;
				cube.position.y = -0.6;
				objects.add(cube.clone());
				
				cube.position.x = -1;
				cube.position.y = -1;
				objects.add(cube.clone());

				return objects;
			}

			const createCamera = function(width, height){
				const camera = new THREE.PerspectiveCamera( 75, width / height, 0.1, 1000 );
				camera.position.y = -2.5;
				camera.position.z = 3;
			    camera.up = new THREE.Vector3(0,0,1);
				camera.lookAt(0,0,0);
				return camera;			
			}

			const createLight = function(x,y,z){
				const light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( x,y,z );
				light.lookAt(0,0,0);
			
				light.shadow.mapSize.width = 2048;
				light.shadow.mapSize.height = 2048;

				return light;
			}

			const enableShadows = function(scene){
				scene.receiveShadow = true;
				scene.castShadow = true;
				
				for(c of scene.children)
					enableShadows(c);
			}

			const friction = function(velo, dt){
				let acceleration = -0.25;

				let v = velo.length() + acceleration * dt;
				if(v < 0)
					v = 0;

				return velo.setLength(v);
			}

			// the ball will receive a velocity impulse v at the time point t
			let v = [ { t : 0, v: new THREE.Vector2(1,0)}, { t: 5, v: new THREE.Vector2(0,1)}, { t: 10, v: new THREE.Vector2(-1,0)}, { t: 15, v: new THREE.Vector2(-0.7,-0.7)}, { t : 20, v: new THREE.Vector2(1,0)}, { t: 25, v: new THREE.Vector2(0,1)}, { t: 30, v: new THREE.Vector2(-1,0)}, { t: 35, v: new THREE.Vector2(-0.7,-0.7)}];

			const velocityImpulse = function(timeSinceStart, velo){
				let t = timeSinceStart;

				for(var i = 0; i < v.length; i++){
					if(v[i] != null && v[i].t < t){
						velo.add(v[i].v);
						v[i] = null;
					}
				}

				return velo;
			}

			let velo = new THREE.Vector2(0,0);
			let pos = new THREE.Vector2(-1,-1);
			let lastTime = 0;

			const ballAnimation = function(timeSinceStart){
				let dt = timeSinceStart - lastTime;
				lastTime = timeSinceStart;

				velo = friction(velo, dt);
				
				velo = velocityImpulse(timeSinceStart, velo);

				pos.add(velo.clone().multiplyScalar(dt));

				return pos;
			}

			const renderer = new THREE.WebGLRenderer();
			renderer.shadowMap.enabled = true;
			renderer.setClearColor(new THREE.Color( 0xffffff ), 1.0);
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setScissorTest( true );
			document.body.appendChild( renderer.domElement );

			const createRenderer = function(x, y, width, height){
				
				return {	camera: createCamera( width, height), 
							render: function(scene, position, lookAt) {
									this.camera.position.x = position.x;
									this.camera.position.y = position.y;
									this.camera.position.z = position.z;
									this.camera.lookAt(lookAt);

									renderer.setViewport(x, y, width, height);
									renderer.setScissor( x, y, width, height );
									renderer.render(scene, this.camera);
								}
						}
			}

			const scene = new THREE.Scene();

			renderers = [];

			const rowCount = 2;
			const columnCount = 2;

			const width = Math.floor(window.innerWidth / rowCount);
			const height = Math.floor(window.innerHeight / columnCount);
			for(let r = 0; r < rowCount; r++)
				for(let c = 0; c < columnCount; c++){
					renderers.push(createRenderer(width * r, height * c, width, height));
				}

			const soccerField = createSoccerField();
			scene.add( soccerField  );

			const ball = createBall();
			scene.add( ball );

			const obstacles = createObstacles();
			scene.add(obstacles);

			const dLight = createLight(3,3,10);
			scene.add(dLight);

			enableShadows(scene);
			
			const aLight = new THREE.AmbientLight( 0x808080 );
			scene.add( aLight );

			cameras = [ {pos : new THREE.Vector3(-3, 2, 1), lookAt: new THREE.Vector3(0,0,0)},
						{pos : new THREE.Vector3(-3, -3, 1), lookAt: new THREE.Vector3(0,0,0)},
						{pos : new THREE.Vector3(3, 2, 1), lookAt: new THREE.Vector3(0,0,0)},
						{pos : new THREE.Vector3(3, -4, 1), lookAt: new THREE.Vector3(0,0,0)}]

			const render = function () {
				const oneSecondInMs = 1000;
				let t = performance.now() / oneSecondInMs;

				p = ballAnimation(t);

				ball.position.x = p.x;
				ball.position.y = p.y;

				console.log("x: " + p.x + ", " + p.y);

				renderers[0].render(scene, new THREE.Vector3(-p.x, -p.y, 3), new THREE.Vector3(0,0,0));

				for(let i = 1; i < renderers.length ; i++)
					renderers[i].render(scene, cameras[i].pos, cameras[i].lookAt);


				requestAnimationFrame( render );
			};

			render();
		</script>
	</body>
</html>